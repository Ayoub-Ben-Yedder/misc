<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Generator</title>
    <style>
        canvas {
            border: 1px solid black;
        }

        body {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 5fr;
        }
    </style>
</head>

<body>
    <h2>DFS</h2>
    <h2>Prim</h2>
    <canvas id="DFS" width="600" height="600"></canvas>
    <canvas id="Prim" width="600" height="600"></canvas>
    <script>
        class Maze {
            constructor(rows, cols) {
                this.rows = rows;
                this.cols = cols;
                this.grid = this.initGrid();
                this.stack = [];
            }

            initGrid() {
                let grid = [];
                for (let r = 0; r < this.rows; r++) {
                    let row = [];
                    for (let c = 0; c < this.cols; c++) {
                        row.push({
                            i: r,
                            j: c,
                            visited: false,
                            top: true,
                            right: true,
                            bottom: true,
                            left: true
                        });
                    }
                    grid.push(row);
                }
                return grid;
            }

            addWalls(cell, walls) {
                const { i, j } = cell;
                if (i > 0 && !this.grid[i - 1][j].visited) walls.push({ current: cell, next: this.grid[i - 1][j] });
                if (i < this.rows - 1 && !this.grid[i + 1][j].visited) walls.push({ current: cell, next: this.grid[i + 1][j] });
                if (j > 0 && !this.grid[i][j - 1].visited) walls.push({ current: cell, next: this.grid[i][j - 1] });
                if (j < this.cols - 1 && !this.grid[i][j + 1].visited) walls.push({ current: cell, next: this.grid[i][j + 1] });
            }

            removeWalls(cell1, cell2) {
                const x = cell1.i - cell2.i;
                const y = cell1.j - cell2.j;

                if (x === 1) {
                    cell1.top = false;
                    cell2.bottom = false;
                } else if (x === -1) {
                    cell1.bottom = false;
                    cell2.top = false;
                }

                if (y === 1) {
                    cell1.left = false;
                    cell2.right = false;
                } else if (y === -1) {
                    cell1.right = false;
                    cell2.left = false;
                }
            }

            getNeighbors(r, c) {
                let neighbors = [];
                if (r > 0) neighbors.push([r - 1, c, 'top', 'bottom']);
                if (c > 0) neighbors.push([r, c - 1, 'left', 'right']);
                if (r < this.rows - 1) neighbors.push([r + 1, c, 'bottom', 'top']);
                if (c < this.cols - 1) neighbors.push([r, c + 1, 'right', 'left']);
                return neighbors;
            }

            generateDFS() {
                let stack = [[0, 0]];
                this.grid[0][0].visited = true;

                while (stack.length > 0) {
                    let [r, c] = stack[stack.length - 1];
                    let neighbors = this.getNeighbors(r, c).filter(
                        ([nr, nc]) => !this.grid[nr][nc].visited
                    );

                    if (neighbors.length > 0) {
                        let [nr, nc, currentWall, nextWall] = neighbors[
                            Math.floor(Math.random() * neighbors.length)
                        ];
                        this.grid[r][c][currentWall] = false;
                        this.grid[nr][nc][nextWall] = false;
                        this.grid[nr][nc].visited = true;
                        stack.push([nr, nc]);
                    } else {
                        stack.pop();
                    }
                }
            }

            generatePrim() {
                const walls = [];
                let current = this.grid[0][0];
                current.visited = true;

                this.addWalls(current, walls);

                while (walls.length > 0) {
                    const randomIndex = Math.floor(Math.random() * walls.length);
                    const { current, next } = walls.splice(randomIndex, 1)[0];

                    if (!next.visited) {
                        this.removeWalls(current, next);
                        next.visited = true;
                        this.addWalls(next, walls);
                    }
                }
            }

            draw(canvasId) {
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                const cellWidth = canvas.width / this.cols;
                const cellHeight = canvas.height / this.rows;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;

                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        let cell = this.grid[r][c];
                        let x = c * cellWidth;
                        let y = r * cellHeight;

                        if (cell.top) {
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + cellWidth, y);
                            ctx.stroke();
                        }
                        if (cell.right) {
                            ctx.beginPath();
                            ctx.moveTo(x + cellWidth, y);
                            ctx.lineTo(x + cellWidth, y + cellHeight);
                            ctx.stroke();
                        }
                        if (cell.bottom) {
                            ctx.beginPath();
                            ctx.moveTo(x, y + cellHeight);
                            ctx.lineTo(x + cellWidth, y + cellHeight);
                            ctx.stroke();
                        }
                        if (cell.left) {
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x, y + cellHeight);
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        const DFS = new Maze(100, 100);
        DFS.generateDFS();
        DFS.draw('DFS');
        const Prim = new Maze(100, 100);
        Prim.generatePrim();
        Prim.draw('Prim');
    </script>
</body>

</html>